cor.test(results$negmusicICC, results$negpicICC)
cor.test(results$allmusicICC, results$allpicICC)
t.test(results$posmusicICC, results$pospicICC, paired = TRUE)
t.test(results$negmusicICC, results$negpicICC, paired = TRUE)
t.test(results$allmusicICC, results$allpicICC, paired = TRUE)
mean_comparison <- results %>%
pivot_longer(negmusicICC:pospicICC) %>%
ggplot(aes(x=name, y=value)) +
stat_summary(fun.data='mean_cl_normal', geom = 'errorbar') +
stat_summary(fun.data='mean_cl_normal', geom = 'pointrange') +
theme_bw() +
xlab('Stimulus and Valence') +
ylab('Average Emotion Granularity') +
ggtitle('Average Granularity Scores by Stimulus Type/Valence (Fisher r to z)') +
theme(axis.title.x = element_text(size=14, face='bold'), axis.title.y = element_text(size=14, face='bold'), axis.text.x = element_text(size=12), axis.text.y = element_text(size=12)) +
scale_x_discrete(labels = c('Negative Music', 'Negative Picture', 'Positive Music', 'Positive Picture'))
ggsave('../results/rating-task/Mean_Comparisons_9_12_24.png', mean_comparison, width = 9)
cor.test(results_recode$posmusicICC, results_recode$pospicICC)
cor.test(results_recode$negmusicICC, results_recode$negpicICC)
cor.test(results_recode$allmusicICC, results_recode$allpicICC)
t.test(results_recode$posmusicICC, results_recode$pospicICC, paired = TRUE)
t.test(results_recode$negmusicICC, results_recode$negpicICC, paired = TRUE)
t.test(results_recode$allmusicICC, results_recode$allpicICC, paired = TRUE)
mean_comparison <- results %>%
pivot_longer(negmusicICC:pospicICC) %>%
ggplot(aes(x=name, y=value)) +
stat_summary(fun.data='mean_cl_normal', geom = 'errorbar', width = 0.2) +
stat_summary(fun.data='mean_cl_normal', geom = 'pointrange', width = 0.2) +
theme_bw() +
xlab('Stimulus and Valence') +
ylab('Average Emotion Granularity') +
ggtitle('Average Granularity Scores by Stimulus Type/Valence (Fisher r to z) (Scores > 1 Recoded)') +
theme(axis.title.x = element_text(size=14, face='bold'), axis.title.y = element_text(size=14, face='bold'), axis.text.x = element_text(size=12), axis.text.y = element_text(size=12)) +
scale_x_discrete(labels = c('Negative Music', 'Negative Picture', 'Positive Music', 'Positive Picture'))
ggsave('../results/rating-task/Mean_Comparisons_Recoded_9_12_24.png', mean_comparison, width = 9)
cor.test(results_recode$posmusicICC, results_recode$pospicICC)
cor.test(results_recode$negmusicICC, results_recode$negpicICC)
cor.test(results_recode$allmusicICC, results_recode$allpicICC)
t.test(results_recode$posmusicICC, results_recode$pospicICC, paired = TRUE)
t.test(results_recode$negmusicICC, results_recode$negpicICC, paired = TRUE)
t.test(results_recode$allmusicICC, results_recode$allpicICC, paired = TRUE)
mean_comparison_recoded <- results_recode %>%
pivot_longer(negmusicICC:pospicICC) %>%
ggplot(aes(x=name, y=value)) +
stat_summary(fun.data='mean_cl_normal', geom = 'errorbar', width = 0.2) +
stat_summary(fun.data='mean_cl_normal', geom = 'pointrange', width = 0.2) +
theme_bw() +
xlab('Stimulus and Valence') +
ylab('Average Emotion Granularity') +
ggtitle('Average Granularity Scores by Stimulus Type/Valence (Fisher r to z) (Scores > 1 Recoded)') +
theme(axis.title.x = element_text(size=14, face='bold'), axis.title.y = element_text(size=14, face='bold'), axis.text.x = element_text(size=12), axis.text.y = element_text(size=12)) +
scale_x_discrete(labels = c('Negative Music', 'Negative Picture', 'Positive Music', 'Positive Picture'))
ggsave('../results/rating-task/Mean_Comparisons_Recoded_9_12_24.png', mean_comparison_recoded, width = 9)
cor.test(results$posmusicICC, results$pospicICC)
cor.test(results$negmusicICC, results$negpicICC)
cor.test(results$allmusicICC, results$allpicICC)
t.test(results$posmusicICC, results$pospicICC, paired = TRUE)
t.test(results$negmusicICC, results$negpicICC, paired = TRUE)
t.test(results$allmusicICC, results$allpicICC, paired = TRUE)
mean_comparison <- results %>%
pivot_longer(negmusicICC:pospicICC) %>%
ggplot(aes(x=name, y=value)) +
stat_summary(fun.data='mean_cl_normal', geom = 'errorbar', width = 0.2) +
stat_summary(fun.data='mean_cl_normal', geom = 'pointrange', width = 0.2) +
theme_bw() +
xlab('Stimulus and Valence') +
ylab('Average Emotion Granularity') +
ggtitle('Average Granularity Scores by Stimulus Type/Valence (Fisher r to z)') +
theme(axis.title.x = element_text(size=14, face='bold'), axis.title.y = element_text(size=14, face='bold'), axis.text.x = element_text(size=12), axis.text.y = element_text(size=12)) +
scale_x_discrete(labels = c('Negative Music', 'Negative Picture', 'Positive Music', 'Positive Picture'))
ggsave('../results/rating-task/Mean_Comparisons_9_12_24.png', mean_comparison, width = 9)
cor.test(results_recode$posmusicICC, results_recode$pospicICC)
cor.test(results_recode$negmusicICC, results_recode$negpicICC)
cor.test(results_recode$allmusicICC, results_recode$allpicICC)
t.test(results_recode$posmusicICC, results_recode$pospicICC, paired = TRUE)
t.test(results_recode$negmusicICC, results_recode$negpicICC, paired = TRUE)
t.test(results_recode$allmusicICC, results_recode$allpicICC, paired = TRUE)
mean_comparison_recoded <- results_recode %>%
pivot_longer(negmusicICC:pospicICC) %>%
ggplot(aes(x=name, y=value)) +
stat_summary(fun.data='mean_cl_normal', geom = 'errorbar', width = 0.2) +
stat_summary(fun.data='mean_cl_normal', geom = 'pointrange', width = 0.2) +
theme_bw() +
xlab('Stimulus and Valence') +
ylab('Average Emotion Granularity') +
ggtitle('Average Granularity Scores by Stimulus Type/Valence (Fisher r to z) (Scores > 1 Recoded)') +
theme(axis.title.x = element_text(size=14, face='bold'), axis.title.y = element_text(size=14, face='bold'), axis.text.x = element_text(size=12), axis.text.y = element_text(size=12)) +
scale_x_discrete(labels = c('Negative Music', 'Negative Picture', 'Positive Music', 'Positive Picture'))
ggsave('../results/rating-task/Mean_Comparisons_Recoded_9_12_24.png', mean_comparison_recoded, width = 9)
# Function to perform correlations and paired t-tests
run_tests <- function(data, label) {
cat(paste0("Results for ", label, ":\n"))
cat("Correlations:\n")
cor.test(data$posmusicICC, data$pospicICC) %>% print()
cor.test(data$negmusicICC, data$negpicICC) %>% print()
cor.test(data$allmusicICC, data$allpicICC) %>% print()
cat("\nPaired T-tests:\n")
t.test(data$posmusicICC, data$pospicICC, paired = TRUE) %>% print()
t.test(data$negmusicICC, data$negpicICC, paired = TRUE) %>% print()
t.test(data$allmusicICC, data$allpicICC, paired = TRUE) %>% print()
}
# Function to create and save mean comparison plot
create_mean_comparison_plot <- function(data, title, output_file) {
mean_comparison <- data %>%
pivot_longer(negmusicICC:pospicICC) %>%
ggplot(aes(x = name, y = value)) +
stat_summary(fun.data = 'mean_cl_normal', geom = 'errorbar', width = 0.2) +
stat_summary(fun.data = 'mean_cl_normal', geom = 'pointrange', width = 0.2) +
theme_bw() +
xlab('Stimulus and Valence') +
ylab('Average Emotion Granularity') +
ggtitle(title) +
theme(axis.title.x = element_text(size = 14, face = 'bold'),
axis.title.y = element_text(size = 14, face = 'bold'),
axis.text.x = element_text(size = 12),
axis.text.y = element_text(size = 12)) +
scale_x_discrete(labels = c('Negative Music', 'Negative Picture', 'Positive Music', 'Positive Picture'))
ggsave(output_file, mean_comparison, width = 9)
}
# Run tests and create plots for non-recoded data
run_tests(results, "Non-Recoded Data")
create_mean_comparison_plot(results,
'Average Granularity Scores by Stimulus Type/Valence (Fisher r to z)',
'../results/rating-task/Mean_Comparisons_9_12_24.png')
# Run tests and create plots for recoded data
run_tests(results_recode, "Recoded Data")
create_mean_comparison_plot(results_recode,
'Average Granularity Scores by Stimulus Type/Valence (Fisher r to z) (Scores > 1 Recoded)',
'../results/rating-task/Mean_Comparisons_Recoded_9_12_24.png')
# Function to calculate effect size (Cohen's d)
effect_size <- function(x, y) {
mean_diff <- mean(x - y, na.rm = TRUE)
sd_diff <- sd(x - y, na.rm = TRUE)
return(mean_diff / sd_diff)
}
# Function to perform power analysis for paired t-tests
power_analysis_t_test <- function(x, y, alpha = 0.05, power = 0.80) {
d <- effect_size(x, y)
sample_size <- pwr.t.test(d = d, power = power, sig.level = alpha, type = "paired")$n
return(list(effect_size = d, sample_size = ceiling(sample_size)))
}
# Function to perform power analysis for correlations
power_analysis_correlation <- function(x, y, alpha = 0.05, power = 0.80) {
cor_test <- cor.test(x, y, method = "pearson")
r <- cor_test$estimate
power_analysis <- pwr.r.test(r = r, sig.level = alpha, power = power)
return(list(correlation = r, power_analysis = power_analysis))
}
# Power analysis for positive granularity scores
pos_t_test <- power_analysis_t_test(results$posmusicICC, results$pospicICC)
paste("Effect size for positive granularity: ", round(pos_t_test$effect_size, 2),
"--> N =", pos_t_test$sample_size, "for 80% power.")
# Power analysis for negative granularity scores
neg_t_test <- power_analysis_t_test(results$negmusicICC, results$negpicICC)
paste("Effect size for negative granularity: ", round(neg_t_test$effect_size, 2),
"--> N =", neg_t_test$sample_size, "for 80% power.")
# Power analysis for combined granularity scores
all_t_test <- power_analysis_t_test(results$allmusicICC, results$allpicICC)
paste("Effect size for combined granularity: ", round(all_t_test$effect_size, 2),
"--> N =", all_t_test$sample_size, "for 80% power.")
# Power analysis for correlations
neg_corr_analysis <- power_analysis_correlation(results$negmusicICC, results$negpicICC)
print(neg_corr_analysis$power_analysis)
pos_corr_analysis <- power_analysis_correlation(results$posmusicICC, results$pospicICC)
print(pos_corr_analysis$power_analysis)
all_corr_analysis <- power_analysis_correlation(results$allmusicICC, results$allpicICC)
print(all_corr_analysis$power_analysis)
# Function to calculate effect size (Cohen's d)
effect_size <- function(x, y) {
mean_diff <- mean(x - y, na.rm = TRUE)
sd_diff <- sd(x - y, na.rm = TRUE)
return(mean_diff / sd_diff)
}
# Function to perform power analysis for paired t-tests
power_analysis_t_test <- function(x, y, alpha = 0.05, power = 0.80) {
d <- effect_size(x, y)
sample_size <- pwr.t.test(d = d, power = power, sig.level = alpha, type = "paired")$n
return(list(effect_size = d, sample_size = ceiling(sample_size)))
}
# Function to perform power analysis for correlations with clear output
power_analysis_correlation <- function(x, y, alpha = 0.05, power = 0.80) {
cor_test <- cor.test(x, y, method = "pearson")
r <- cor_test$estimate
power_analysis <- pwr.r.test(r = r, sig.level = alpha, power = power)
sample_size <- ceiling(power_analysis$n)
# Displaying the result in a clear output
cat("Correlation Analysis:\n")
cat("Correlation coefficient (r):", round(r, 2), "\n")
cat("Required sample size for 80% power:", sample_size, "\n")
cat("Power analysis details:\n")
print(power_analysis)
return(list(correlation = r, sample_size = sample_size, power_analysis = power_analysis))
}
# Power analysis for positive granularity scores
pos_t_test <- power_analysis_t_test(results$posmusicICC, results$pospicICC)
paste("Effect size for positive granularity: ", round(pos_t_test$effect_size, 2),
"--> N =", pos_t_test$sample_size, "for 80% power.")
# Power analysis for negative granularity scores
neg_t_test <- power_analysis_t_test(results$negmusicICC, results$negpicICC)
paste("Effect size for negative granularity: ", round(neg_t_test$effect_size, 2),
"--> N =", neg_t_test$sample_size, "for 80% power.")
# Power analysis for combined granularity scores
all_t_test <- power_analysis_t_test(results$allmusicICC, results$allpicICC)
paste("Effect size for combined granularity: ", round(all_t_test$effect_size, 2),
"--> N =", all_t_test$sample_size, "for 80% power.")
# Power analysis for correlations with clear output
cat("\nNegative Granularity Correlation Analysis:\n")
neg_corr_analysis <- power_analysis_correlation(results$negmusicICC, results$negpicICC)
cat("\nPositive Granularity Correlation Analysis:\n")
pos_corr_analysis <- power_analysis_correlation(results$posmusicICC, results$pospicICC)
cat("\nCombined Granularity Correlation Analysis:\n")
all_corr_analysis <- power_analysis_correlation(results$allmusicICC, results$allpicICC)
# Function to calculate effect size (Cohen's d)
effect_size <- function(x, y) {
mean_diff <- mean(x - y, na.rm = TRUE)
sd_diff <- sd(x - y, na.rm = TRUE)
return(mean_diff / sd_diff)
}
# Function to perform power analysis for paired t-tests
power_analysis_t_test <- function(x, y, alpha = 0.05, power = 0.80) {
d <- effect_size(x, y)
sample_size <- pwr.t.test(d = d, power = power, sig.level = alpha, type = "paired")$n
return(list(effect_size = d, sample_size = ceiling(sample_size)))
}
# Function to perform power analysis for correlations with clear output
power_analysis_correlation <- function(x, y, alpha = 0.05, power = 0.80) {
cor_test <- cor.test(x, y, method = "pearson")
r <- cor_test$estimate
power_analysis <- pwr.r.test(r = r, sig.level = alpha, power = power)
sample_size <- ceiling(power_analysis$n)
# Displaying the result in a clear output
cat("Correlation Analysis:\n")
cat("Correlation coefficient (r):", round(r, 2), "\n")
cat("Required sample size for 80% power:", sample_size, "\n")
cat("Power analysis details:\n")
print(power_analysis)
return(list(correlation = r, sample_size = sample_size, power_analysis = power_analysis))
}
# Power analysis for positive granularity scores
pos_t_test <- power_analysis_t_test(results$posmusicICC, results$pospicICC)
paste("Effect size for positive granularity: ", round(pos_t_test$effect_size, 2),
"--> N =", pos_t_test$sample_size, "for 80% power.")
# Power analysis for negative granularity scores
neg_t_test <- power_analysis_t_test(results$negmusicICC, results$negpicICC)
paste("Effect size for negative granularity: ", round(neg_t_test$effect_size, 2),
"--> N =", neg_t_test$sample_size, "for 80% power.")
# Power analysis for combined granularity scores
all_t_test <- power_analysis_t_test(results$allmusicICC, results$allpicICC)
paste("Effect size for combined granularity: ", round(all_t_test$effect_size, 2),
"--> N =", all_t_test$sample_size, "for 80% power.")
# Power analysis for correlations with clear output
cat("\nNegative Granularity Correlation Analysis:\n")
neg_corr_analysis <- power_analysis_correlation(results$negmusicICC, results$negpicICC)
cat("\nPositive Granularity Correlation Analysis:\n")
pos_corr_analysis <- power_analysis_correlation(results$posmusicICC, results$pospicICC)
cat("\nCombined Granularity Correlation Analysis:\n")
all_corr_analysis <- power_analysis_correlation(results$allmusicICC, results$allpicICC)
#### FOR RECODED SCORES
# Power analysis for positive granularity scores
print('FOR RECODED SCORES')
pos_t_test_recode <- power_analysis_t_test(results_recode$posmusicICC, results_recode$pospicICC)
paste("Effect size for positive granularity: ", round(pos_t_test_recode$effect_size, 2),
"--> N =", pos_t_test_recode$sample_size, "for 80% power.")
# Power analysis for negative granularity scores
neg_t_test_recode <- power_analysis_t_test(results_recode$negmusicICC, results_recode$negpicICC)
paste("Effect size for negative granularity: ", round(neg_t_test_recode$effect_size, 2),
"--> N =", neg_t_test_recode$sample_size, "for 80% power.")
# Power analysis for combined granularity scores
all_t_test_recode <- power_analysis_t_test(results_recode$allmusicICC, results_recode$allpicICC)
paste("Effect size for combined granularity: ", round(all_t_test_recode$effect_size, 2),
"--> N =", all_t_test_recode$sample_size, "for 80% power.")
# Power analysis for correlations with clear output
cat("\nNegative Granularity Correlation Analysis:\n")
neg_corr_analysis_recode <- power_analysis_correlation(results_recode$negmusicICC, results_recode$negpicICC)
cat("\nPositive Granularity Correlation Analysis:\n")
pos_corr_analysis_recode <- power_analysis_correlation(results_recode$posmusicICC, results_recode$pospicICC)
cat("\nCombined Granularity Correlation Analysis:\n")
all_corr_analysis_recode <- power_analysis_correlation(results_recode$allmusicICC, results_recode$allpicICC)
# Function to calculate effect size (Cohen's d)
effect_size <- function(x, y) {
mean_diff <- mean(x - y, na.rm = TRUE)
sd_diff <- sd(x - y, na.rm = TRUE)
return(mean_diff / sd_diff)
}
# Function to perform power analysis for paired t-tests
power_analysis_t_test <- function(x, y, alpha = 0.05, power = 0.80) {
d <- effect_size(x, y)
sample_size <- pwr.t.test(d = d, power = power, sig.level = alpha, type = "paired")$n
return(list(effect_size = d, sample_size = ceiling(sample_size)))
}
# Function to perform power analysis for correlations with clear output
power_analysis_correlation <- function(x, y, alpha = 0.05, power = 0.80) {
cor_test <- cor.test(x, y, method = "pearson")
r <- cor_test$estimate
power_analysis <- pwr.r.test(r = r, sig.level = alpha, power = power)
sample_size <- ceiling(power_analysis$n)
# Displaying the result in a clear output
cat("Correlation Analysis:\n")
cat("Correlation coefficient (r):", round(r, 2), "\n")
cat("Required sample size for 80% power:", sample_size, "\n")
cat("Power analysis details:\n")
print(power_analysis)
return(list(correlation = r, sample_size = sample_size, power_analysis = power_analysis))
}
# Power analysis for positive granularity scores
pos_t_test <- power_analysis_t_test(results$posmusicICC, results$pospicICC)
paste("Effect size for positive granularity: ", round(pos_t_test$effect_size, 2),
"--> N =", pos_t_test$sample_size, "for 80% power.")
# Power analysis for negative granularity scores
neg_t_test <- power_analysis_t_test(results$negmusicICC, results$negpicICC)
paste("Effect size for negative granularity: ", round(neg_t_test$effect_size, 2),
"--> N =", neg_t_test$sample_size, "for 80% power.")
# Power analysis for combined granularity scores
all_t_test <- power_analysis_t_test(results$allmusicICC, results$allpicICC)
paste("Effect size for combined granularity: ", round(all_t_test$effect_size, 2),
"--> N =", all_t_test$sample_size, "for 80% power.")
# Power analysis for correlations with clear output
cat("\nNegative Granularity Correlation Analysis:\n")
neg_corr_analysis <- power_analysis_correlation(results$negmusicICC, results$negpicICC)
cat("\nPositive Granularity Correlation Analysis:\n")
pos_corr_analysis <- power_analysis_correlation(results$posmusicICC, results$pospicICC)
cat("\nCombined Granularity Correlation Analysis:\n")
all_corr_analysis <- power_analysis_correlation(results$allmusicICC, results$allpicICC)
#### FOR RECODED SCORES
# Power analysis for positive granularity scores
print('FOR RECODED SCORES')
pos_t_test_recode <- power_analysis_t_test(results_recode$posmusicICC, results_recode$pospicICC)
paste("Effect size for positive granularity: ", round(pos_t_test_recode$effect_size, 2),
"--> N =", pos_t_test_recode$sample_size, "for 80% power.")
# Power analysis for negative granularity scores
neg_t_test_recode <- power_analysis_t_test(results_recode$negmusicICC, results_recode$negpicICC)
paste("Effect size for negative granularity: ", round(neg_t_test_recode$effect_size, 2),
"--> N =", neg_t_test_recode$sample_size, "for 80% power.")
# Power analysis for combined granularity scores
all_t_test_recode <- power_analysis_t_test(results_recode$allmusicICC, results_recode$allpicICC)
paste("Effect size for combined granularity: ", round(all_t_test_recode$effect_size, 2),
"--> N =", all_t_test_recode$sample_size, "for 80% power.")
# Power analysis for correlations with clear output
cat("\nNegative Granularity Correlation Analysis:\n")
neg_corr_analysis_recode <- power_analysis_correlation(results_recode$negmusicICC, results_recode$negpicICC)
cat("\nPositive Granularity Correlation Analysis:\n")
pos_corr_analysis_recode <- power_analysis_correlation(results_recode$posmusicICC, results_recode$pospicICC)
cat("\nCombined Granularity Correlation Analysis:\n")
all_corr_analysis_recode <- power_analysis_correlation(results_recode$allmusicICC, results_recode$allpicICC)
grouped_averages <- split(all_averages, all_averages$Type)
for(group_name in names(grouped_averages)) {
# Get the specific dataframe for the current group
df_group <- grouped_averages[[group_name]]
# Identify the non-NA column (either Spreadsheet..Audio or Spreadsheet..Image)
df_group <- df_group %>%
mutate(Stimulus = ifelse(!is.na(Spreadsheet..Audio), Spreadsheet..Audio, Spreadsheet..Image))
# Create the confusion matrix plot
p <- ggplot(df_group, aes(x = Object.Name, y = Stimulus, fill = Average.Response)) +
geom_tile() +
ggtitle(paste("Average Responses by Emotion and Stimulus for", group_name)) +
xlab("Emotion") +
ylab("Stimulus") +
scale_fill_gradient(low = "blue", high = "red") +  # Adjust color scheme as needed
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"), axis.text.y = element_text(color = "black"), plot.background = element_rect(fill = "white", color = NA),  # Set plot background to white
panel.background = element_rect(fill = "white", color = NA))  # Rotate x-axis labels for readability
# Print and save the plots
print(p)
ggsave(paste("../results/rating-task/", group_name, ".png"), p, width = 9)
}
grouped_averages <- split(all_averages, all_averages$Type)
View(grouped_averages)
View(grouped_averages[["Music"]])
grouped_averages <- split(all_averages, all_averages$Type)
for(group_name in names(grouped_averages)) {
# Get the specific dataframe for the current group
df_group <- grouped_averages[[group_name]]
# Identify the non-NA column (either Spreadsheet..Audio or Spreadsheet..Image)
df_group <- df_group %>%
mutate(Stimulus = ifelse(!is.na(Spreadsheet..Audio), Spreadsheet..Audio, Spreadsheet..Image))
# Create the confusion matrix plot
p <- ggplot(df_group, aes(x = Object.Name, y = Stimulus, fill = Average.Response)) +
geom_tile() +
ggtitle(paste("Average Responses by Emotion and Stimulus for", group_name)) +
xlab("Emotion") +
ylab("Stimulus") +
scale_fill_gradient(low = "blue", high = "red") +  # Adjust color scheme as needed
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"), axis.text.y = element_text(color = "black"), plot.background = element_rect(fill = "white", color = NA),  # Set plot background to white
panel.background = element_rect(fill = "white", color = NA))  # Rotate x-axis labels for readability
# Print and save the plots
print(p)
ggsave(paste("../results/rating-task/", group_name, ".png"), p, width = 9)
}
View(all_averages)
View(all_averages)
all_averages$Object.Name <- gsub("Slider", "", all_averages$Object.Name)
# 8 clips
averages_pos_music <- pos_music_data %>%
group_by(Spreadsheet..Audio, Object.Name) %>%
summarise(
Average.Response = mean(Response, na.rm = TRUE),
se_value = sd(Response, na.rm = TRUE) / sqrt(n())
)
# 8 clips
averages_neg_music <- neg_music_data %>%
group_by(Spreadsheet..Audio, Object.Name) %>%
summarise(
Average.Response = mean(Response, na.rm = TRUE),
se_value = sd(Response, na.rm = TRUE) / sqrt(n())
)
# 8 pics
averages_pos_pic <- pos_pic_data %>%
group_by(Spreadsheet..Image, Object.Name) %>%
summarise(
Average.Response = mean(Response, na.rm = TRUE),
se_value = sd(Response, na.rm = TRUE) / sqrt(n())
)
# 8 pics
averages_neg_pic <- neg_pic_data %>%
group_by(Spreadsheet..Image, Object.Name) %>%
summarise(
Average.Response = mean(Response, na.rm = TRUE),
se_value = sd(Response, na.rm = TRUE) / sqrt(n())
)
all_averages <- bind_rows(
averages_pos_music %>% mutate(Type = "Positive Valence Music"),
averages_neg_music %>% mutate(Type = "Negative Valence Music"),
averages_pos_pic %>% mutate(Type = "Positive Valence Pictures"),
averages_neg_pic %>% mutate(Type = "Negative Valence Pictures"),
)
all_averages$Object.Name <- gsub("Slider", "", all_averages$Object.Name)
# Trim any extra whitespace that might be left after removing "Slider"
all_averages$Object.Name <- trimws(all_averages$Object.Name)
emotion_order <- c("Angry", "Anxious", "Sad", "Scared", "Upset", "Excited", "Happy", "Joyful", "Relaxed", "Satisfied")
all_averages$Object.Name <- factor(all_averages$Object.Name, levels = emotion_order)
grouped_averages <- split(all_averages, all_averages$Type)
for(group_name in names(grouped_averages)) {
# Get the specific dataframe for the current group
df_group <- grouped_averages[[group_name]]
# Identify the non-NA column (either Spreadsheet..Audio or Spreadsheet..Image)
df_group <- df_group %>%
mutate(Stimulus = ifelse(!is.na(Spreadsheet..Audio), Spreadsheet..Audio, Spreadsheet..Image))
# Create the confusion matrix plot
p <- ggplot(df_group, aes(x = Object.Name, y = Stimulus, fill = Average.Response)) +
geom_tile() +
ggtitle(paste("Average Responses by Emotion and Stimulus for", group_name)) +
xlab("Emotion") +
ylab("Stimulus") +
scale_fill_gradient(low = "blue", high = "red") +  # Adjust color scheme as needed
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"), axis.text.y = element_text(color = "black"), plot.background = element_rect(fill = "white", color = NA),  # Set plot background to white
panel.background = element_rect(fill = "white", color = NA))  # Rotate x-axis labels for readability
# Print and save the plots
print(p)
ggsave(paste("../results/rating-task/", group_name, ".png"), p, width = 9)
}
# 8 clips
averages_pos_music <- pos_music_data %>%
group_by(Spreadsheet..Audio, Object.Name) %>%
summarise(
Average.Response = mean(Response, na.rm = TRUE),
se_value = sd(Response, na.rm = TRUE) / sqrt(n())
)
# 8 clips
averages_neg_music <- neg_music_data %>%
group_by(Spreadsheet..Audio, Object.Name) %>%
summarise(
Average.Response = mean(Response, na.rm = TRUE),
se_value = sd(Response, na.rm = TRUE) / sqrt(n())
)
# 8 pics
averages_pos_pic <- pos_pic_data %>%
group_by(Spreadsheet..Image, Object.Name) %>%
summarise(
Average.Response = mean(Response, na.rm = TRUE),
se_value = sd(Response, na.rm = TRUE) / sqrt(n())
)
# 8 pics
averages_neg_pic <- neg_pic_data %>%
group_by(Spreadsheet..Image, Object.Name) %>%
summarise(
Average.Response = mean(Response, na.rm = TRUE),
se_value = sd(Response, na.rm = TRUE) / sqrt(n())
)
all_averages <- bind_rows(
averages_pos_music %>% mutate(Type = "Positive Valence Music"),
averages_neg_music %>% mutate(Type = "Negative Valence Music"),
averages_pos_pic %>% mutate(Type = "Positive Valence Pictures"),
averages_neg_pic %>% mutate(Type = "Negative Valence Pictures"),
)
all_averages$Object.Name <- gsub("Slider", "", all_averages$Object.Name)
# Trim any extra whitespace that might be left after removing "Slider"
all_averages$Object.Name <- trimws(all_averages$Object.Name)
emotion_order <- c("Gloomy", "Anxious", "Sad", "Scared", "Upset", "Excited", "Happy", "Joyful", "Relaxed", "Satisfied")
all_averages$Object.Name <- factor(all_averages$Object.Name, levels = emotion_order)
grouped_averages <- split(all_averages, all_averages$Type)
for(group_name in names(grouped_averages)) {
# Get the specific dataframe for the current group
df_group <- grouped_averages[[group_name]]
# Identify the non-NA column (either Spreadsheet..Audio or Spreadsheet..Image)
df_group <- df_group %>%
mutate(Stimulus = ifelse(!is.na(Spreadsheet..Audio), Spreadsheet..Audio, Spreadsheet..Image))
# Create the confusion matrix plot
p <- ggplot(df_group, aes(x = Object.Name, y = Stimulus, fill = Average.Response)) +
geom_tile() +
ggtitle(paste("Average Responses by Emotion and Stimulus for", group_name)) +
xlab("Emotion") +
ylab("Stimulus") +
scale_fill_gradient(low = "blue", high = "red") +  # Adjust color scheme as needed
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, color = "black"), axis.text.y = element_text(color = "black"), plot.background = element_rect(fill = "white", color = NA),  # Set plot background to white
panel.background = element_rect(fill = "white", color = NA))  # Rotate x-axis labels for readability
# Print and save the plots
print(p)
ggsave(paste("../results/rating-task/", group_name, ".png"), p, width = 9)
}
